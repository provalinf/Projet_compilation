package analyse ;

import java.util.*;
import arbre.* ;
import arbre.instruction.* ;
import arbre.fonctions.* ;
import arbre.expression.* ;
import arbre.comparaison.* ;
import tds.*;
import exceptions.AnalyseSyntaxiqueException;

import java_cup.runtime.*;

action code {: 
             :} ;

parser code {:

    public void report_error(String message, Object info) {

        HashMap<Integer, String> lesTerminaux = new HashMap<>() ;
    
        lesTerminaux.put(new Integer(CodesLexicaux.PLUS), "+") ;
        lesTerminaux.put(new Integer(CodesLexicaux.MOINS), "-") ;
        lesTerminaux.put(new Integer(CodesLexicaux.MULT), "*") ;
        lesTerminaux.put(new Integer(CodesLexicaux.DIV), "/") ;
        lesTerminaux.put(new Integer(CodesLexicaux.PAROUV), "(") ;
        lesTerminaux.put(new Integer(CodesLexicaux.PARFER), ")") ;
        lesTerminaux.put(new Integer(CodesLexicaux.SUP), ">") ;
        lesTerminaux.put(new Integer(CodesLexicaux.INF), "<") ;
        lesTerminaux.put(new Integer(CodesLexicaux.EGALEGAL), "==") ;
        lesTerminaux.put(new Integer(CodesLexicaux.DIFF), "!=") ;
        lesTerminaux.put(new Integer(CodesLexicaux.ET), "et") ;
        lesTerminaux.put(new Integer(CodesLexicaux.OU), "ou") ;
        lesTerminaux.put(new Integer(CodesLexicaux.NON), "non") ;

        StringBuffer m = new StringBuffer() ;

        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);

            if (s.left >= 0) {                
                m.append("\tligne : " + (s.left + 1)) ;
                if (s.right >= 0)                    
                    m.append(" colonne : " + (s.right+1)) ;
            }
            
            if (s.value != null) {
                lesTerminaux.put(CodesLexicaux.CONSTANTEINT, "" + s.value) ;
                lesTerminaux.put(CodesLexicaux.CONSTANTEBOOL, "" + s.value) ;
            }

            if (lesTerminaux.containsKey(new Integer(s.sym))) {
                m.append(" dernier token lu : " + lesTerminaux.get(new Integer(s.sym))) ;
            }
            else {
                m.append(" expression non terminée") ;
            }

        }
        throw new AnalyseSyntaxiqueException("" + m) ;
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
    }
:};
   
/* ------------Declaration of Terminals and Non Terminals Section----------- */
   
/* Terminals (tokens returned by the scanner).  */

terminal Symbol PROGRAMME, DEBUT, FIN, POINTVIRGULE, ECR, LIRE, TANTQUE, REPETER, FINTANTQUE, SI, ALORS, SINON, FINSI, FONCTION, RETOURNE;

terminal Symbol    PLUS, MOINS, MULT, DIV, PAROUV, PARFER/*, ACCOUV, ACCFER*/;
terminal Symbol    SUP, INF, EGAL, EGALEGAL, DIFF, ET, OU, NON;
terminal String    TYPE, CONSTANTEINT, CONSTANTEBOOL, CSTECHAINE, IDF;
   
/* Non terminals used in the grammar section.  */

non terminal BlocDInstructions PROG, LINSTR, LDECL, DECLARATION, PARAM/*, DECL_VAR, DECL_FONCTION, RETOURNE*/;
non terminal Instruction INSTRUCTION, AFFECT, ECRIRE, CONDITION, BOUCLE, FONC;
non terminal Expression EXPR, CSTE ;

precedence left OU ;
precedence left ET ;
precedence left EGALEGAL, DIFF;
precedence left INF, SUP ;
precedence left PLUS, MOINS;
precedence left MULT, DIV ;
precedence left NON ;


/* ----------------------------Grammar Section-------------------- */
 
start with PROG;

PROG::= PROGRAMME IDF DEBUT LDECL LINSTR:lI FIN
			{: RESULT = lI; :}
		| PROGRAMME IDF DEBUT LINSTR:lI FIN
			{: RESULT = lI; :}
		| PROGRAMME IDF DEBUT LDECL FIN
			{: RESULT = new BlocDInstructions(0); :}
		;

LINSTR::= LINSTR:lI INSTRUCTION:I
		{:
			lI.ajouter(I);
			RESULT = lI;
		:}
		| INSTRUCTION:I
		{:
			//System.out.println(I+" "+Ileft+" "+Iright);
			BlocDInstructions lI = new BlocDInstructions(Ileft+1);
			lI.ajouter(I);
			RESULT = lI;
		:}
		;

LDECL::= LDECL:ldecl DECLARATION:decl1
		{:
			/*ldecl.ajouter(decl1);
			RESULT = ldecl;*/
		:}
		| DECLARATION:decl2
		{:
			/* BlocDInstructions dec = new BlocDInstructions(decl2left+1);
			RESULT = dec;*/
		:}
		;

DECLARATION::= TYPE:t IDF:idf POINTVIRGULE
			{: TableSymbole.getInstance().ajouter(new EntreeVariable(idf), new SymboleSimple(t)); :}
			;

INSTRUCTION::= AFFECT:aff
			{: RESULT=aff; :}
		| BOUCLE:bou
			{: RESULT=bou; :}
		| CONDITION:con
			{: RESULT=con; :}
		| LIRE IDF:i POINTVIRGULE
			{: RESULT=new Lire(i, ileft+1); :}
		| ECRIRE:ecr
			{: RESULT=ecr; :}
		| IDF:i PAROUV PARFER POINTVIRGULE
			{: RESULT=new AppelFonction(i, ileft); :}
		| FONC:fonc
			{: RESULT=fonc; :}
		/*| RETOURNE CSTECHAINE:c POINTVIRGULE
			{: RESULT=new RetourneFonction(new EcrireString(c, cleft)); :}*/
		| RETOURNE EXPR:e POINTVIRGULE
			{: RESULT=new RetourneFonction(e); :}
		;

EXPR::= EXPR:g PLUS EXPR:d
			{: RESULT = new Plus(g, d); :}
		| EXPR:g MOINS EXPR:d
			{: RESULT = new Moins(g, d); :}
		| EXPR:g MULT EXPR:d
			{: RESULT = new Mult(g, d); :}
		| EXPR:g DIV EXPR:d
			{: RESULT = new Div(g, d); :}
		| EXPR:g INF EXPR:d
			{: RESULT = new Inferieur(g, d); :}
		| EXPR:g SUP EXPR:d
			{: RESULT = new Superieur(g, d); :}
		| EXPR:g EGALEGAL EXPR:d
			{: RESULT = new Egal(g, d); :}
		| EXPR:g DIFF EXPR:d
			{: RESULT = new Different(g, d); :}
		| MOINS EXPR:e
			{: RESULT = new MoinsUnaire(e); :}
		| EXPR:g ET EXPR:d
			{: RESULT = new EtLogique(g, d); :}
		| EXPR:g OU EXPR:d
			{: RESULT = new OuLogique(g, d); :}
		| NON EXPR:e
			{: RESULT = new NonLogique(e); :}
		| CSTE:c
			{: RESULT = c; :}
		| PAROUV EXPR:e PARFER
			{: RESULT = e; :}
		| IDF:i
			{: RESULT = new Variable(i, ileft+1); :}
		;

AFFECT::= IDF:idf EGAL EXPR:e POINTVIRGULE
		{:
			RESULT = new Affectation(idf, e);
		:}
		;

ECRIRE::= ECR EXPR:e POINTVIRGULE
		{:
			RESULT=new EcrireExpression(e);
		:}
		|
		ECR CSTECHAINE:cste POINTVIRGULE
		{:
			RESULT=new EcrireString(cste,csteleft+1);
		:}
		;

BOUCLE::= TANTQUE EXPR:e REPETER LINSTR:lI FINTANTQUE
		{:
			RESULT=new Boucle(eleft+1, e, lI);
		:}
		;

CONDITION::= SI EXPR:e ALORS LINSTR:lI FINSI
		{:
			RESULT=new Condition(e, lI, null, eleft+1);
		:}
		| SI EXPR:e ALORS FINSI
		{:
			RESULT=new Condition(e, null, null, eleft+1);
		:}
		| SI EXPR:e ALORS LINSTR:lI1 SINON LINSTR:lI2 FINSI
		{:
			RESULT=new Condition(e, lI1, lI2, eleft+1);
		:}
		| SI EXPR:e ALORS LINSTR:lI SINON FINSI
		{:
			RESULT=new Condition(e, lI, null, eleft+1);
		:}
		| SI EXPR:e ALORS SINON LINSTR:lI FINSI
		{:
			RESULT=new Condition(e, null, lI, eleft+1);
		:}
		| SI EXPR:e ALORS SINON FINSI
		{:
			RESULT=new Condition(e, null, null, eleft+1);
		:}
		;

CSTE::= CONSTANTEINT:cste
			{: RESULT = new ConstanteEntiere(cste, csteleft+1); :}
		| CONSTANTEBOOL:cste
			{: RESULT = new ConstanteBool(cste, csteleft+1); :}
		;

FONC::= FONCTION IDF:nameFonc PAROUV PARAM:param PARFER DEBUT LINSTR:lI FIN	// Pour déclaration variables
        {:
           TableSymbole.getInstance().ajouter(new EntreeFonction(nameFonc, 0), new SymboleFonction(null));
           RESULT = new FonctionsAvecParam(nameFonc, lI, param);
        :}

		| FONCTION IDF:nameFonc PAROUV PARFER DEBUT LINSTR:lI FIN
            {:
             TableSymbole.getInstance().ajouter(new EntreeFonction(nameFonc, 0), new SymboleFonction(null));
             RESULT = new FonctionsSansParam(nameFonc, lI);
            :}
            ;
